function solution(name) {
  let answer = 0;
  let n = name.length;
  let minMove = n - 1; // 최소 좌우 이동 횟수를 일단 가장 큰 값으로 설정 (오른쪽으로만 이동하는 경우)

  for (let i = 0; i < n; i++) {
    // 각 문자에 대해 조이스틱을 움직여 알파벳을 변경하는 최소 횟수를 계산
    let next = i + 1;
    // 현재 문자까지의 상하 조작 횟수 추가
    answer += Math.min(
      name.charCodeAt(i) - "A".charCodeAt(0),
      "Z".charCodeAt(0) - name.charCodeAt(i) + 1
    );

    // 다음 문자가 A인 동안 계속 이동하며 A가 아닌 문자가 나올 때까지의 인덱스를 찾음
    while (next < n && name[next] === "A") {
      next++;
    }

    // 현재 위치 i에서 다시 되돌아가서 next까지의 최소 이동 거리를 계산
    // minMove는 초기값과, 왼쪽으로 돌아간 다음 오른쪽으로 이동하는 경우 중 최소값
    minMove = Math.min(minMove, i + n - next + Math.min(i, n - next));
  }

  // 상하 조작 횟수 + 좌우 조작 최소 횟수
  answer += minMove;
  return answer;
}

// 조이스틱 문제를 해결하기 위해 JavaScript 코드의 핵심 로직은 두 부분으로 나눌 수 있습니다: 알파벳 변경과 최적의 커서 이동 계산입니다. 이 두 가지 요소를 효과적으로 결합하여 최소 조작 횟수를 구합니다.

// 1. 알파벳 변경 최소 횟수 계산
// 각 문자 위치에서 가장 빠른 방법으로 원하는 알파벳으로 변경하기 위한 횟수를 계산합니다. 이를 위해 각 문자에 대해 두 가지 경로를 고려합니다:

// 'A'에서 위로 이동하여 해당 문자로: 예를 들어 'A'에서 'J'로 가기 위해서는 위로 9번 이동해야 합니다 (J - A).
// 'Z'를 넘어서 아래로 이동하여 해당 문자로: 'A'에서 'J'로 가는 또 다른 방법은 'Z'로 가고 'Z'에서 한 번 더 아래로 가서 'J'가 되는 것입니다. 이는 총 2번의 이동이 필요합니다 (Z - J + 1).
// 이 중 최소값을 선택하여 총 이동 횟수에 더합니다.

// 2. 최적의 커서 이동 계산
// 커서를 이동하여 다음 변경할 알파벳 위치로 가는 것은 좀 더 복잡합니다. 각 문자에서 다음 변경할 문자까지의 최소 이동 거리를 계산해야 합니다. 여기서 몇 가지 시나리오를 고려할 수 있습니다:

// 오른쪽으로만 이동: 간단하게 문자열 끝까지 오른쪽으로 이동합니다. 이 경우 이동 횟수는 n-1입니다.
// 왼쪽으로 이동 후 다시 오른쪽으로: 중간에 'A'가 연속으로 있을 경우, 이를 건너뛰어 이동 시간을 단축할 수 있습니다. 이를 위해 다음과 같은 계산을 합니다:
// i에서 왼쪽으로 돌아가 (i 횟수) 'A'가 아닌 다음 문자로 이동하는데 필요한 추가 이동 횟수를 계산합니다.
// 'A'가 연속되는 부분을 지나 다음 문자까지의 최소 이동을 계산합니다.
// 이러한 계산을 통해 각 위치에서 최적의 경로를 계산하고, 모든 가능한 경로 중에서 최소 이동 횟수를 찾아 minMove에 저장합니다. 이동하는 동안의 최소 횟수는 i + n - next + Math.min(i, n - next)로 계산되며, 이는 현재 위치에서 뒤로 돌아가 다시 필요한 위치까지 최소 비용으로 이동하는 것을 의미합니다.

// 결론
// 이 두 계산 방식을 통합하여, 알파벳 변경 횟수와 커서 이동 횟수를 합산하면 조이스틱으로 문자열을 완성하기 위한 최소 조작 횟수를 얻을 수 있습니다. 이 방식은 주어진 이름에 대해 가능한 최소 조작 횟수를 계산하는 효율적인 알고리즘입니다.
